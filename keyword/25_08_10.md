### ✅ 수직 확장

- 보통 스케일 아웃을 많이함 → 비용적으로도, 구현적으로도 더 장점이 있기 때문
- 그렇다면 스케일 업을 하는 상황은 어떤게 있을까?
    - 서비스가 초기단계라 작아서 스케일 업이 용이한 상황
    - 소규모 서비스에서 비용상 분산보다 이점이 있는 경우

### ✅ JWT Slient Refresh

- 사용자가 인지하지 못하게 백그라운드에서 JWT 토큰을 자동으로 갱신하는 기법
- 리프레시 토큰을 사용하여 만료된 액세스 토큰을 갱신
- 플로우 예시
    1. 클라이언트는 액세스 토큰이 만료되기 전에 또는 만료될 때
    2. 리프레시 토큰 사용하여 새로운 액세스 토큰을 발급 → 백엔드 API 호출
    3. 새 액세스 토큰 발급
    4. 새 액세스 토큰 사용
- 즉 자동화된 토큰 재발급으로 사용자는 끊김없이 서비스 이용 가능

### ✅ PK → UUID vs **Auto Increment**

- 커서 기반 페이지네이션 구현 시 PK가 UUID인 경우 어떻게?
    - PK 이외의 정렬을 위한 컬럼을 따로 두어서 구현한다.
- PK 선택은 웬만하면 Auto Increment → 가독성, 정렬 등
- UUID가 필요한 케이스?
    - 보안이 중요할 때 → PK가 AI인 경우 조회 API 등을 통해 정보 유추 및 DB의 데이터 양 등을 유추할 수 있음
- [참고](https://devs0n.tistory.com/87)

### ✅ CSMA/CD와 CSMA/CA

- CSMA/CD: 유선
- CSMA/CA: 무선
- [참고](https://dev-ws.tistory.com/118)

### ✅ 정규화와 이상현상

**정규화: DB 중복을 제거하고 데이터 무결성을 보장하는 과정 → 즉 중복을 없애는 과정**

- 1NF: 모든 컬럼 값이 원자값이어야함 → 하나의 셀에 여러 값 포함 X
- 2NF: 부분적 함수 종속 제거
- 3NF: 이행적 함수 종속 제거
- BCNF: 모든 결정자가 후보키가 되도록

**이상현상: 정규화가 제대로 되지 않아 발생하는 데이터 불일치 문제**

- 삽입 이상: 투플 삽입 시 특정 속성에 해당하는 값이 없어 NULL값을 입력해하는 현상

    ```
    학생테이블: [학번, 이름, 과목코드, 과목명, 성적]
    ```

    - 문제: 새 과목을 등록하려면 반드시 수강하는 학생이 있어야 함
    - 해결: 과목 정보를 별도 테이블로 분리
- 삭제 이상: 투플 삭제시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상 → 연쇄삭제 문제발생

    ```
    위와 같은 테이블에서 마지막 수강생을 삭제하면
    → 과목 정보까지 함께 사라짐
    ```

    - 문제: 한 레코드 삭제 시 중요한 정보까지 손실
    - 해결: 테이블 분리로 독립성 확보
- 갱신 이상: 투플 수정 시 중복된 데이터의 일부만 수정되어 데이터이 불일치 문제가 일어나는 현상 → 불일치 문제 발생

    ```
    과목명이 변경될 때
    → 해당 과목을 수강하는 모든 학생 레코드를 수정해야 함
    ```

    - 문제: 동일 정보가 여러 곳에 중복 저장되어 일관성 문제 발생
    - 해결: 정규화를 통한 중복 제거

### ✅ TCP/UDP

**TCP (Transmission Control Protocol)**

- 신뢰성 중심의 연결형 프로토콜

**특징**

- 연결 설정: 3-way handshake로 연결 확립
- 신뢰성 보장: 데이터 순서, 무결성, 전달 보장
- 흐름 제어: 수신자 처리 속도에 맞춰 전송
- 혼잡 제어: 네트워크 상황에 따라 전송량 조절

**장점**

- 데이터 손실 없음
- 순서 보장

**단점**

- 속도가 상대적으로 느림
- 오버헤드 존재

**사용 예**

- HTTP/HTTPS, 이메일, 파일 전송, 웹 브라우징

**UDP (User Datagram Protocol)**

- 속도 중심의 비연결형 프로토콜

**특징**

- 비연결성: 연결 설정 과정 없음
- 빠른 전송: 최소한의 헤더, 단순한 구조
- 신뢰성 없음: 데이터 손실, 순서 바뀜 가능
- 브로드캐스트: 일대다 통신 지원

**장점**

- 빠른 속도
- 적은 오버헤드

**단점**

- 데이터 손실 가능
- 순서 보장 안됨

**사용 예**

- 실시간 스트리밍
- 온라인 게임
- DNS, DHCP

**UDP에서 데이터 손실이 있을 수 있는 이유**

- TCP와 다르게 연결 지향형 프로토콜이 아님 → 송수신자간에 연결을 먼저 설정하지않고 데이터를 보냄
- TCP는 ACK가 있어서, 패킷 전송 후에 잘 받았는지가 확인되는데, UDP는 없음
- UDP는 패킷 전송간 순서를 보장하지 않음

**실시간 스트리밍, 온라인 게임에서 UDP를 사용하는 이유**

- 속도 보다는 레이턴시(지연)에 민감한 서비스 특성때문에 UDP를 사용
- 영상 스트리밍의 경우는 프레임 1~2개가 유실되어도, 사용자가 불편함을 거의 느끼지 못함
- 하지만 TCP는 유실된 패킷을 기다림→ 재전송을 하면 화면이 멈추거나 지연되는 현상 발생 -> 오히려 사용자 경험이 좋지 않음

**webRTC는 UDP인가?**

- 시그널은 TCP로, 영상과 미디어는 UDP로 날림
- 최초 iceCandidate는 TCP로 주고 받지만, 이후 진행되는 핵심적인 미디어 파트는 여타 VoIP기술처럼 UDP 프로토콜 기반
- TCP는 UDP보다 우선순위가 높음 → TCP 요청이 쏟아지면 순위가 낮은 UDP는 뒤로 밀리게 됨
- [참고](https://butfound.tistory.com/38)

**그런데 결국**

- UDP에서 로직적으로 보완을 하거나, 프로토콜을 조금 더 다듬는 방향으로 부분적인 신뢰성을 확보 가능하지만,
- 결국 이 작업이 고도화되다보면 TCP 형태의 프로토콜이 탄생함

### ✅ 대칭키와 비대칭키

**대칭키 암호화 (Symmetric Key Cryptography)**

**특징**

- 암호화와 복호화에 **같은 키**를 사용
- 송신자와 수신자가 미리 같은 비밀키를 공유해야 함

**장점**

- 처리 속도가 매우 빠름
- 계산 부담이 적어 대용량 데이터 처리에 적합

**단점**

- 키 배송 문제: 안전하게 키를 전달하기 어려움
- 키 관리 복잡성: n명이 통신하려면 n(n-1)/2개의 키가 필요

**비대칭키 암호화 (Asymmetric Key Cryptography)**

**특징**

- **공개키**와 **개인키** 한 쌍을 사용
- 공개키로 암호화하면 개인키로만 복호화 가능
- 개인키로 서명하면 공개키로 검증 가능

**장점**

- 키 배송 문제 해결: 공개키는 누구나 알 수 있음
- 디지털 서명 가능
- 키 관리가 상대적으로 간단

**단점**

- 처리 속도가 느림 (대칭키 대비 100-1000배)
- 계산 부담이 큼

**실제로는**

- 실제로는 두 방식을 **하이브리드**로 사용합
    1. 비대칭키로 대칭키를 안전하게 전달
    2. 전달받은 대칭키로 실제 데이터를 암호화
- HTTPS, TLS 등에서 이런 방식을 사용 → https 동작방식 알아볼 것